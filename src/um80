#!/usr/bin/env python3
"""
um80 - Microsoft MACRO-80 compatible assembler for Linux.

Usage: um80 [-o output.rel] [-l listing.prn] input.mac
"""

import sys
import os
import re
import argparse
from pathlib import Path

# Add src directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from opcodes8080 import *
from relformat import *


class AssemblerError(Exception):
    """Assembler error with line information."""
    def __init__(self, message, line_num=None, line_text=None):
        self.message = message
        self.line_num = line_num
        self.line_text = line_text
        super().__init__(self.format_message())

    def format_message(self):
        if self.line_num:
            return f"Error at line {self.line_num}: {self.message}"
        return f"Error: {self.message}"


class Symbol:
    """Symbol table entry."""
    def __init__(self, name, value=0, seg_type=ADDR_ABSOLUTE,
                 defined=False, public=False, external=False):
        self.name = name.upper()
        self.value = value
        self.seg_type = seg_type  # ADDR_ABSOLUTE, ADDR_PROGRAM_REL, etc.
        self.defined = defined
        self.public = public
        self.external = external
        self.references = []  # Line numbers where referenced


class Segment:
    """Code/data segment."""
    def __init__(self, name, seg_type):
        self.name = name
        self.seg_type = seg_type
        self.loc = 0  # Location counter
        self.size = 0  # High water mark
        self.data = bytearray()


class Macro:
    """Macro definition."""
    def __init__(self, name, params, body):
        self.name = name.upper()
        self.params = params  # List of parameter names
        self.body = body  # List of source lines


class Assembler:
    """MACRO-80 compatible assembler."""

    def __init__(self, predefined=None):
        self.symbols = {}  # Symbol table
        self.macros = {}   # Macro definitions
        self.segments = {
            'ASEG': Segment('ASEG', ADDR_ABSOLUTE),
            'CSEG': Segment('CSEG', ADDR_PROGRAM_REL),
            'DSEG': Segment('DSEG', ADDR_DATA_REL),
        }
        self.common_blocks = {}  # COMMON blocks
        self.current_seg = 'CSEG'  # Default is code segment
        self.current_common = None  # Current COMMON block if any

        self.pass_num = 1
        self.line_num = 0
        self.errors = []
        self.warnings = []

        self.radix = 10  # Default numeric radix
        self.list_on = True
        self.cond_stack = []  # Conditional assembly stack
        self.cond_false_depth = 0  # Depth of false conditionals

        self.local_counter = 0  # For LOCAL symbols in macros
        self.expanding_macro = False
        self.macro_level = 0

        # Macro definition collection state
        self.collecting_macro = None  # Name of macro being defined
        self.macro_params = []  # Parameters of macro being defined
        self.macro_body = []  # Lines of macro being defined
        self.macro_nest_depth = 0  # For nested MACRO/ENDM

        # REPT/IRP/IRPC state
        self.repeat_stack = []  # Stack of (type, count/list, body, iter_var)

        self.entry_point = None  # END address if specified
        self.module_name = None

        # Add predefined symbols from command line
        if predefined:
            for name, value in predefined.items():
                sym = Symbol(name, value, ADDR_ABSOLUTE, defined=True)
                self.symbols[name] = sym

        # External reference chains
        self.ext_chains = {}  # name -> list of (seg, offset, expr_offset) references

        # Forward reference chains (for labels within module)
        self.fwd_chains = {}  # name -> list of (seg, offset) references

        self.output = RELWriter()
        self.listing_lines = []
        self.source_lines = []

    @property
    def loc(self):
        """Current location counter."""
        if self.current_common:
            return self.common_blocks[self.current_common].loc
        return self.segments[self.current_seg].loc

    @loc.setter
    def loc(self, value):
        if self.current_common:
            self.common_blocks[self.current_common].loc = value
        else:
            self.segments[self.current_seg].loc = value

    @property
    def seg_type(self):
        """Current segment type."""
        if self.current_common:
            return ADDR_COMMON_REL
        return self.segments[self.current_seg].seg_type

    def error(self, msg):
        """Record an error."""
        self.errors.append(AssemblerError(msg, self.line_num))

    def warning(self, msg):
        """Record a warning."""
        self.warnings.append(f"Warning at line {self.line_num}: {msg}")

    def define_symbol(self, name, value, seg_type=None, public=False):
        """Define or update a symbol."""
        name = name.upper()
        if seg_type is None:
            seg_type = self.seg_type

        if name in self.symbols:
            sym = self.symbols[name]
            if sym.defined and sym.value != value and not sym.external:
                if self.pass_num == 2:
                    self.error(f"Symbol '{name}' multiply defined")
                return
            sym.value = value
            sym.seg_type = seg_type
            sym.defined = True
            if public:
                sym.public = True
        else:
            self.symbols[name] = Symbol(name, value, seg_type, defined=True, public=public)

    def lookup_symbol(self, name):
        """Look up a symbol, creating undefined entry if needed."""
        name = name.upper()
        if name not in self.symbols:
            self.symbols[name] = Symbol(name)
        return self.symbols[name]

    def parse_number(self, s):
        """Parse a numeric constant, return (value, success)."""
        s = s.strip().upper()
        if not s:
            return (0, False)

        # Check for suffix notation
        if s.endswith('H'):
            try:
                return (int(s[:-1], 16), True)
            except ValueError:
                return (0, False)
        elif s.endswith('O') or s.endswith('Q'):
            try:
                return (int(s[:-1], 8), True)
            except ValueError:
                return (0, False)
        elif s.endswith('B'):
            try:
                return (int(s[:-1], 2), True)
            except ValueError:
                return (0, False)
        elif s.endswith('D'):
            try:
                return (int(s[:-1], 10), True)
            except ValueError:
                return (0, False)

        # Check for X'nn' hex notation
        if s.startswith("X'") and s.endswith("'"):
            try:
                return (int(s[2:-1], 16), True)
            except ValueError:
                return (0, False)

        # Check for leading 0 prefix for hex that starts with letter
        if s and s[0].isdigit():
            try:
                return (int(s, self.radix), True)
            except ValueError:
                # Try hex if it looks like hex
                try:
                    return (int(s, 16), True)
                except ValueError:
                    return (0, False)

        return (0, False)

    def parse_char_const(self, s):
        """Parse character constant like 'A' or 'AB'."""
        if len(s) >= 2 and s[0] in "'\"" and s[-1] == s[0]:
            chars = s[1:-1]
            if len(chars) == 1:
                return (ord(chars), True)
            elif len(chars) == 2:
                return (ord(chars[0]) | (ord(chars[1]) << 8), True)
        return (0, False)

    def find_op_at_level0(self, expr, ops):
        """
        Find the rightmost occurrence of any operator in ops at parenthesis level 0.
        Returns (index, op_len) or (-1, 0) if not found.
        Properly skips over string/character constants.
        """
        # First, mark positions that are inside strings
        in_string = [False] * len(expr)
        i = 0
        while i < len(expr):
            if expr[i] in "'\"":
                quote_char = expr[i]
                start = i
                i += 1
                while i < len(expr) and expr[i] != quote_char:
                    i += 1
                if i < len(expr):
                    # Mark all chars from start to i (inclusive) as in string
                    for j in range(start, i + 1):
                        in_string[j] = True
                i += 1
            else:
                i += 1

        level = 0
        i = len(expr) - 1
        while i >= 0:
            if in_string[i]:
                i -= 1
                continue
            ch = expr[i]
            if ch == ')':
                level += 1
            elif ch == '(':
                level -= 1
            elif level == 0:
                for op in ops:
                    if i >= len(op) - 1:
                        # Check if op matches at position i-len(op)+1
                        start = i - len(op) + 1
                        # Make sure none of the op chars are in a string
                        if any(in_string[j] for j in range(start, i + 1)):
                            continue
                        if expr[start:i+1].upper() == op.upper():
                            # Make sure it's not part of a larger token
                            if op[0].isalpha():
                                # Word operator - needs boundaries
                                before_ok = (start == 0 or not expr[start-1].isalnum())
                                after_ok = (i+1 >= len(expr) or not expr[i+1].isalnum())
                                if before_ok and after_ok:
                                    return (start, len(op))
                            else:
                                # Symbol operator
                                return (start, len(op))
            i -= 1
        return (-1, 0)

    def parse_expression(self, expr, allow_undefined=False):
        """
        Parse an expression, return (value, seg_type, is_external, ext_name).
        Uses recursive descent with proper precedence and parenthesis handling.
        """
        expr = expr.strip()
        if not expr:
            return (0, ADDR_ABSOLUTE, False, None)

        # Handle special symbols
        if expr == '$':
            return (self.loc, self.seg_type, False, None)

        # Handle unary operators first
        upper = expr.upper()
        if upper.startswith('HIGH '):
            val, seg, ext, name = self.parse_expression(expr[5:], allow_undefined)
            return ((val >> 8) & 0xFF, ADDR_ABSOLUTE, ext, name)
        if upper.startswith('LOW '):
            val, seg, ext, name = self.parse_expression(expr[4:], allow_undefined)
            return (val & 0xFF, ADDR_ABSOLUTE, ext, name)
        if upper.startswith('NOT '):
            val, seg, ext, name = self.parse_expression(expr[4:], allow_undefined)
            return ((~val) & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # Handle unary minus at start (but not subtraction)
        if expr.startswith('-') and len(expr) > 1:
            val, seg, ext, name = self.parse_expression(expr[1:], allow_undefined)
            return ((-val) & 0xFFFF, seg, ext, name)

        # Handle unary plus at start
        if expr.startswith('+') and len(expr) > 1:
            return self.parse_expression(expr[1:], allow_undefined)

        # Handle parenthesized expression - check if balanced outer parens
        if expr.startswith('('):
            level = 0
            for i, ch in enumerate(expr):
                if ch == '(':
                    level += 1
                elif ch == ')':
                    level -= 1
                    if level == 0:
                        if i == len(expr) - 1:
                            # Entire expr is wrapped in parens
                            return self.parse_expression(expr[1:-1], allow_undefined)
                        else:
                            # Parens close before end, not fully wrapped
                            break

        # Lowest precedence: OR
        idx, oplen = self.find_op_at_level0(expr, [' OR '])
        if idx >= 0:
            left_val, _, _, _ = self.parse_expression(expr[:idx], allow_undefined)
            right_val, _, _, _ = self.parse_expression(expr[idx+oplen:], allow_undefined)
            return ((left_val | right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # XOR
        idx, oplen = self.find_op_at_level0(expr, [' XOR '])
        if idx >= 0:
            left_val, _, _, _ = self.parse_expression(expr[:idx], allow_undefined)
            right_val, _, _, _ = self.parse_expression(expr[idx+oplen:], allow_undefined)
            return ((left_val ^ right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # AND
        idx, oplen = self.find_op_at_level0(expr, [' AND '])
        if idx >= 0:
            left_val, _, _, _ = self.parse_expression(expr[:idx], allow_undefined)
            right_val, _, _, _ = self.parse_expression(expr[idx+oplen:], allow_undefined)
            return ((left_val & right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # Comparison operators: EQ, NE, LT, LE, GT, GE
        idx, oplen = self.find_op_at_level0(expr, [' EQ ', ' NE ', ' LT ', ' LE ', ' GT ', ' GE '])
        if idx >= 0:
            op = expr[idx:idx+oplen].strip().upper()
            left_val, _, _, _ = self.parse_expression(expr[:idx], allow_undefined)
            right_val, _, _, _ = self.parse_expression(expr[idx+oplen:], allow_undefined)
            if op == 'EQ':
                result = 0xFFFF if left_val == right_val else 0
            elif op == 'NE':
                result = 0xFFFF if left_val != right_val else 0
            elif op == 'LT':
                result = 0xFFFF if left_val < right_val else 0
            elif op == 'LE':
                result = 0xFFFF if left_val <= right_val else 0
            elif op == 'GT':
                result = 0xFFFF if left_val > right_val else 0
            elif op == 'GE':
                result = 0xFFFF if left_val >= right_val else 0
            else:
                result = 0
            return (result, ADDR_ABSOLUTE, False, None)

        # Addition and subtraction (lowest arithmetic precedence, right to left)
        idx, oplen = self.find_op_at_level0(expr, ['+', '-'])
        if idx >= 0:
            op = expr[idx:idx+oplen]
            left = expr[:idx].strip()
            right = expr[idx+oplen:].strip()

            # Don't split if left side is empty (unary operator case handled above)
            if left:
                left_val, left_seg, left_ext, left_name = self.parse_expression(left, allow_undefined)
                right_val, right_seg, right_ext, right_name = self.parse_expression(right, allow_undefined)

                if left_ext or right_ext:
                    # External reference with offset
                    ext_name = left_name if left_ext else right_name
                    offset = right_val if left_ext else left_val
                    if op == '-' and not left_ext:
                        offset = -offset
                    return (offset, ADDR_ABSOLUTE, True, ext_name)

                if op == '+':
                    result = left_val + right_val
                else:
                    result = left_val - right_val

                # Determine result segment type
                if left_seg == right_seg and op == '-':
                    result_seg = ADDR_ABSOLUTE
                elif right_seg == ADDR_ABSOLUTE:
                    result_seg = left_seg
                elif left_seg == ADDR_ABSOLUTE:
                    result_seg = right_seg
                else:
                    result_seg = left_seg

                return (result & 0xFFFF, result_seg, False, None)

        # Multiplication, division, MOD, SHL, SHR
        idx, oplen = self.find_op_at_level0(expr, ['*', '/', ' MOD ', ' SHL ', ' SHR '])
        if idx >= 0:
            op = expr[idx:idx+oplen].strip().upper()
            left_val, _, _, _ = self.parse_expression(expr[:idx], allow_undefined)
            right_val, _, _, _ = self.parse_expression(expr[idx+oplen:], allow_undefined)
            if op == '*':
                return ((left_val * right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)
            elif op == '/':
                if right_val == 0:
                    self.error("Division by zero")
                    return (0, ADDR_ABSOLUTE, False, None)
                return ((left_val // right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)
            elif op == 'MOD':
                if right_val == 0:
                    self.error("Division by zero")
                    return (0, ADDR_ABSOLUTE, False, None)
                return ((left_val % right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)
            elif op == 'SHL':
                return ((left_val << right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)
            elif op == 'SHR':
                return ((left_val >> right_val) & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # Handle ## suffix (6-character truncation operator, implies external)
        if expr.endswith('##'):
            # Truncate symbol to 6 chars and look it up
            sym_name = expr[:-2][:6]
            sym = self.lookup_symbol(sym_name)
            if sym.external:
                return (0, ADDR_ABSOLUTE, True, sym.name)
            if not sym.defined:
                # ## implies external if not defined locally
                sym.external = True
                return (0, ADDR_ABSOLUTE, True, sym.name)
            return (sym.value, sym.seg_type, False, None)

        # Try as simple symbol
        if re.match(r'^[$A-Za-z_@?][A-Za-z0-9_@?$.]*$', expr):
            # Check if it's a register (not a symbol)
            upper = expr.upper()
            if upper in REGS or upper in REGPAIRS or upper in REGPAIRS_PUSHPOP:
                self.error(f"Register '{expr}' used as value")
                return (0, ADDR_ABSOLUTE, False, None)

            sym = self.lookup_symbol(expr)
            if sym.external:
                return (0, ADDR_ABSOLUTE, True, sym.name)
            if not sym.defined and not allow_undefined:
                if self.pass_num == 2:
                    self.error(f"Undefined symbol '{expr}'")
                return (0, ADDR_ABSOLUTE, False, None)
            return (sym.value, sym.seg_type, False, None)

        # Try as number
        val, ok = self.parse_number(expr)
        if ok:
            return (val & 0xFFFF, ADDR_ABSOLUTE, False, None)

        # Try as character constant
        val, ok = self.parse_char_const(expr)
        if ok:
            return (val & 0xFFFF, ADDR_ABSOLUTE, False, None)

        self.error(f"Cannot parse expression: '{expr}'")
        return (0, ADDR_ABSOLUTE, False, None)

    def parse_line(self, line):
        """Parse a source line, return (label, operator, operands, comment)."""
        # Remove comment
        comment = ''
        in_string = False
        string_char = None
        for i, ch in enumerate(line):
            if in_string:
                if ch == string_char:
                    in_string = False
            elif ch in "'\"":
                in_string = True
                string_char = ch
            elif ch == ';':
                comment = line[i+1:]
                line = line[:i]
                break

        line = line.rstrip()
        if not line:
            return (None, None, None, comment)

        # Parse label (if any)
        label = None
        if line and not line[0].isspace():
            # Label at start of line
            match = re.match(r'^([$A-Za-z_@?][A-Za-z0-9_@?$.]*)(:?:?)\s*', line)
            if match:
                label = match.group(1)
                colons = match.group(2)
                line = line[match.end():]
                # Double colon makes it PUBLIC
                if colons == '::':
                    self.lookup_symbol(label).public = True

        if not line.strip():
            return (label, None, None, comment)

        # Parse operator
        line = line.strip()
        match = re.match(r'^([$A-Za-z_@?.][A-Za-z0-9_@?$.]*)\s*', line)
        if not match:
            return (label, None, line, comment)

        operator = match.group(1).upper()
        operands = line[match.end():].strip()

        return (label, operator, operands, comment)

    def split_operands(self, operands):
        """Split operands by comma, respecting strings, parentheses, and angle brackets."""
        if not operands:
            return []

        result = []
        current = ''
        paren_depth = 0
        angle_depth = 0
        in_string = False
        string_char = None

        for ch in operands:
            if in_string:
                current += ch
                if ch == string_char:
                    in_string = False
            elif ch in "'\"":
                in_string = True
                string_char = ch
                current += ch
            elif ch == '(':
                paren_depth += 1
                current += ch
            elif ch == ')':
                paren_depth -= 1
                current += ch
            elif ch == '<':
                angle_depth += 1
                current += ch
            elif ch == '>':
                angle_depth -= 1
                current += ch
            elif ch == ',' and paren_depth == 0 and angle_depth == 0:
                result.append(current.strip())
                current = ''
            else:
                current += ch

        if current.strip():
            result.append(current.strip())

        return result

    def emit_byte(self, value):
        """Emit a byte to current segment."""
        if self.pass_num == 2:
            self.output.write_absolute_byte(value & 0xFF)
        self.loc += 1

    def emit_word(self, value, seg_type=ADDR_ABSOLUTE):
        """Emit a 16-bit word to current segment."""
        if self.pass_num == 2:
            if seg_type == ADDR_ABSOLUTE:
                self.output.write_absolute_byte(value & 0xFF)
                self.output.write_absolute_byte((value >> 8) & 0xFF)
            elif seg_type == ADDR_PROGRAM_REL:
                self.output.write_program_relative(value)
            elif seg_type == ADDR_DATA_REL:
                self.output.write_data_relative(value)
            elif seg_type == ADDR_COMMON_REL:
                self.output.write_common_relative(value)
        self.loc += 2

    def emit_external_ref(self, name, offset=0):
        """Emit reference to external symbol.

        The offset parameter is the expression offset (e.g., +1 in RNDX+1),
        which is added to the resolved address during linking.

        External references form a chain - each location contains the offset
        of the previous reference (or 0 for the first). The linker walks the
        chain backwards from the head (last reference) to resolve all refs.

        Separate chains are maintained for each unique (name, offset) pair,
        so RNDX and RNDX+1 have independent chains.
        """
        name = name.upper()
        # Key by (name, expr_offset) so different offsets get separate chains
        chain_key = (name, offset)
        if chain_key not in self.ext_chains:
            self.ext_chains[chain_key] = []

        # Get the previous reference location (for chain link) or 0 if first
        chain = self.ext_chains[chain_key]
        if chain:
            prev_seg, prev_offset = chain[-1]
            chain_link = prev_offset
        else:
            chain_link = 0

        # Record this reference location (will be the new head)
        chain.append((self.seg_type, self.loc))

        # Emit chain link (0 for first reference, else previous offset)
        self.emit_word(chain_link)

    def assemble_instruction(self, operator, operands):
        """Assemble a CPU instruction."""
        operator = operator.upper()
        ops = self.split_operands(operands) if operands else []

        # No-operand instructions
        if operator in NO_OPERAND:
            if ops:
                self.warning(f"Operands ignored for {operator}")
            code = encode_no_operand(operator)
            for b in code:
                self.emit_byte(b)
            return True

        # Conditional returns
        if operator in COND_RETS:
            cond = get_cond_from_mnemonic(operator)
            code = encode_cond_ret(cond)
            for b in code:
                self.emit_byte(b)
            return True

        # MOV dst, src
        if operator == 'MOV':
            if len(ops) != 2:
                self.error("MOV requires two operands")
                return True
            dst, src = ops[0].upper(), ops[1].upper()
            if dst not in REGS or src not in REGS:
                self.error(f"Invalid register for MOV: {dst}, {src}")
                return True
            if dst == 'M' and src == 'M':
                self.error("MOV M,M is invalid (HLT)")
                return True
            code = encode_mov(dst, src)
            for b in code:
                self.emit_byte(b)
            return True

        # MVI reg, imm8
        if operator == 'MVI':
            if len(ops) != 2:
                self.error("MVI requires two operands")
                return True
            reg = ops[0].upper()
            if reg not in REGS:
                self.error(f"Invalid register for MVI: {reg}")
                return True
            val, seg, ext, name = self.parse_expression(ops[1])
            if ext:
                self.error("Cannot use external in immediate byte")
                return True
            code = encode_mvi(reg, val)
            for b in code:
                self.emit_byte(b)
            return True

        # LXI rp, imm16
        if operator == 'LXI':
            if len(ops) != 2:
                self.error("LXI requires two operands")
                return True
            rp = ops[0].upper()
            if rp not in REGPAIRS:
                self.error(f"Invalid register pair for LXI: {rp}")
                return True
            self.emit_byte(LXI_BASE | (REGPAIRS[rp] << 4))
            val, seg, ext, name = self.parse_expression(ops[1])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # INR/DCR reg
        if operator in ('INR', 'DCR'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            reg = ops[0].upper()
            if reg not in REGS:
                self.error(f"Invalid register for {operator}: {reg}")
                return True
            if operator == 'INR':
                code = encode_inr(reg)
            else:
                code = encode_dcr(reg)
            for b in code:
                self.emit_byte(b)
            return True

        # INX/DCX/DAD rp
        if operator in ('INX', 'DCX', 'DAD'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            rp = ops[0].upper()
            if rp not in REGPAIRS:
                self.error(f"Invalid register pair for {operator}: {rp}")
                return True
            if operator == 'INX':
                code = encode_inx(rp)
            elif operator == 'DCX':
                code = encode_dcx(rp)
            else:
                code = encode_dad(rp)
            for b in code:
                self.emit_byte(b)
            return True

        # LDAX/STAX rp (B or D only)
        if operator in ('LDAX', 'STAX'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            rp = ops[0].upper()
            if rp not in REGPAIRS_LDAX:
                self.error(f"Invalid register pair for {operator}: {rp} (must be B or D)")
                return True
            if operator == 'LDAX':
                code = encode_ldax(rp)
            else:
                code = encode_stax(rp)
            for b in code:
                self.emit_byte(b)
            return True

        # PUSH/POP rp
        if operator in ('PUSH', 'POP'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            rp = ops[0].upper()
            if rp not in REGPAIRS_PUSHPOP:
                self.error(f"Invalid register pair for {operator}: {rp}")
                return True
            if operator == 'PUSH':
                code = encode_push(rp)
            else:
                code = encode_pop(rp)
            for b in code:
                self.emit_byte(b)
            return True

        # ALU with register (ADD, ADC, SUB, SBB, ANA, XRA, ORA, CMP)
        if operator in ALU_REG:
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            reg = ops[0].upper()
            if reg not in REGS:
                self.error(f"Invalid register for {operator}: {reg}")
                return True
            code = encode_alu_reg(operator, reg)
            for b in code:
                self.emit_byte(b)
            return True

        # ALU immediate (ADI, ACI, SUI, SBI, ANI, XRI, ORI, CPI)
        if operator in ALU_IMM:
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.error("Cannot use external in immediate byte")
                return True
            code = encode_alu_imm(operator, val)
            for b in code:
                self.emit_byte(b)
            return True

        # JMP addr
        if operator == 'JMP':
            if len(ops) != 1:
                self.error("JMP requires one operand")
                return True
            self.emit_byte(JMP)
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # Conditional jumps
        if operator in COND_JUMPS:
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            cond = get_cond_from_mnemonic(operator)
            self.emit_byte(COND_JMP_BASE | (CONDITIONS[cond] << 3))
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # CALL addr
        if operator == 'CALL':
            if len(ops) != 1:
                self.error("CALL requires one operand")
                return True
            self.emit_byte(CALL)
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # Conditional calls
        if operator in COND_CALLS:
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            cond = get_cond_from_mnemonic(operator)
            self.emit_byte(COND_CALL_BASE | (CONDITIONS[cond] << 3))
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # RST n
        if operator == 'RST':
            if len(ops) != 1:
                self.error("RST requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0])
            if val > 7:
                self.error("RST operand must be 0-7")
                return True
            code = encode_rst(val)
            for b in code:
                self.emit_byte(b)
            return True

        # LDA/STA/LHLD/SHLD addr
        if operator in ('LDA', 'STA', 'LHLD', 'SHLD'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            if operator == 'LDA':
                self.emit_byte(LDA)
            elif operator == 'STA':
                self.emit_byte(STA)
            elif operator == 'LHLD':
                self.emit_byte(LHLD)
            else:
                self.emit_byte(SHLD)
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.emit_external_ref(name, val)
            else:
                self.emit_word(val, seg)
            return True

        # IN/OUT port
        if operator in ('IN', 'OUT'):
            if len(ops) != 1:
                self.error(f"{operator} requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.error("Cannot use external for port number")
                return True
            if operator == 'IN':
                code = encode_in(val)
            else:
                code = encode_out(val)
            for b in code:
                self.emit_byte(b)
            return True

        return False  # Not a CPU instruction

    def assemble_pseudo_op(self, operator, operands, label):
        """Assemble a pseudo-operation (directive)."""
        operator = operator.upper()
        ops = self.split_operands(operands) if operands else []

        # ORG - set location counter
        if operator == 'ORG':
            if len(ops) != 1:
                self.error("ORG requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.error("Cannot use external in ORG")
                return True
            self.loc = val
            if self.pass_num == 2:
                self.output.write_set_location(self.seg_type, val)
            return True

        # EQU - equate symbol to value
        if operator == 'EQU':
            if not label:
                self.error("EQU requires a label")
                return True
            if len(ops) != 1:
                self.error("EQU requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0], allow_undefined=(self.pass_num == 1))
            if ext:
                self.error("Cannot use external in EQU")
                return True
            self.define_symbol(label, val, seg)
            return True

        # SET - like EQU but redefinable
        if operator == 'SET':
            if not label:
                self.error("SET requires a label")
                return True
            if len(ops) != 1:
                self.error("SET requires one operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0], allow_undefined=(self.pass_num == 1))
            if ext:
                self.error("Cannot use external in SET")
                return True
            # SET allows redefinition
            sym = self.lookup_symbol(label)
            sym.value = val
            sym.seg_type = seg
            sym.defined = True
            return True

        # DB - define bytes
        if operator in ('DB', 'DEFB', 'DEFM'):
            for op in ops:
                op = op.strip()
                # Check for string
                if (op.startswith("'") and op.endswith("'")) or \
                   (op.startswith('"') and op.endswith('"')):
                    s = op[1:-1]
                    # Handle '' escape sequence (doubled apostrophe = single apostrophe)
                    s = s.replace("''", "'")
                    for ch in s:
                        self.emit_byte(ord(ch))
                else:
                    val, seg, ext, name = self.parse_expression(op)
                    if ext:
                        self.error("Cannot use external in DB")
                    else:
                        self.emit_byte(val)
            return True

        # DC - define character string (M80 compatible - no high bit modification)
        if operator == 'DC':
            if len(ops) != 1:
                self.error("DC requires one string operand")
                return True
            op = ops[0].strip()
            if (op.startswith("'") and op.endswith("'")) or \
               (op.startswith('"') and op.endswith('"')):
                s = op[1:-1]
                # Handle '' escape sequence (doubled apostrophe = single apostrophe)
                s = s.replace("''", "'")
                if not s:
                    self.error("DC requires non-empty string")
                    return True
                for ch in s:
                    self.emit_byte(ord(ch))
            else:
                self.error("DC requires a string operand")
            return True

        # DW - define words
        if operator in ('DW', 'DEFW'):
            for op in ops:
                val, seg, ext, name = self.parse_expression(op.strip())
                if ext:
                    self.emit_external_ref(name, val)
                else:
                    self.emit_word(val, seg)
            return True

        # DS - define space
        if operator in ('DS', 'DEFS'):
            if len(ops) < 1:
                self.error("DS requires size operand")
                return True
            val, seg, ext, name = self.parse_expression(ops[0])
            if ext:
                self.error("Cannot use external in DS")
                return True
            # Just advance location counter (don't emit anything for DS)
            if self.pass_num == 2:
                # For REL format, we need to advance by emitting zeros or using set_location
                # Using set_location to skip over the space
                new_loc = self.loc + val
                self.output.write_set_location(self.seg_type, new_loc)
            self.loc += val
            return True

        # CSEG/DSEG/ASEG - segment selection
        if operator == 'CSEG':
            self.current_seg = 'CSEG'
            self.current_common = None
            return True
        if operator == 'DSEG':
            self.current_seg = 'DSEG'
            self.current_common = None
            return True
        if operator == 'ASEG':
            self.current_seg = 'ASEG'
            self.current_common = None
            return True

        # COMMON - define/select common block
        if operator == 'COMMON':
            name = ''
            if ops:
                name = ops[0].strip()
                if name.startswith('/') and name.endswith('/'):
                    name = name[1:-1]
            if name not in self.common_blocks:
                self.common_blocks[name] = Segment(name, ADDR_COMMON_REL)
            self.current_common = name
            if self.pass_num == 2:
                self.output.write_select_common(name if name else ' ')
            return True

        # PUBLIC/ENTRY - declare public symbols
        if operator in ('PUBLIC', 'ENTRY', 'GLOBAL'):
            for op in ops:
                sym = self.lookup_symbol(op.strip())
                sym.public = True
            return True

        # EXTRN/EXT/EXTERNAL - declare external symbols
        if operator in ('EXTRN', 'EXT', 'EXTERNAL'):
            for op in ops:
                sym = self.lookup_symbol(op.strip())
                sym.external = True
            return True

        # NAME - module name
        if operator == 'NAME':
            if ops:
                name = ops[0].strip()
                if name.startswith("'") or name.startswith('"'):
                    name = name[1:-1]
                elif name.startswith('(') and name.endswith(')'):
                    name = name[1:-1]
                self.module_name = name
            return True

        # TITLE/SUBTTL - listing titles (ignore for now)
        if operator in ('TITLE', 'SUBTTL'):
            return True

        # PAGE - new page in listing (ignore for now)
        if operator == 'PAGE':
            return True

        # .LIST/.XLIST - listing control
        if operator == '.LIST':
            self.list_on = True
            return True
        if operator == '.XLIST':
            self.list_on = False
            return True

        # .RADIX - set default radix
        if operator == '.RADIX':
            if len(ops) != 1:
                self.error(".RADIX requires one operand")
                return True
            val, _, _, _ = self.parse_expression(ops[0])
            if val < 2 or val > 16:
                self.error("Radix must be 2-16")
                return True
            self.radix = val
            return True

        # .Z80/.8080 - processor mode (we only support 8080)
        if operator == '.8080':
            return True
        if operator == '.Z80':
            self.warning(".Z80 mode not fully supported, using 8080")
            return True

        # .SALL/.LALL/.XALL - macro listing control
        if operator in ('.SALL', '.LALL', '.XALL'):
            return True

        # .SFCOND/.LFCOND/.TFCOND - conditional listing control
        if operator in ('.SFCOND', '.LFCOND', '.TFCOND'):
            return True

        # .PRINTX - print message during assembly
        if operator == '.PRINTX':
            if operands and self.pass_num == 2:
                msg = operands.strip()
                if len(msg) >= 2:
                    delim = msg[0]
                    if msg[-1] == delim:
                        msg = msg[1:-1]
                print(msg)
            return True

        # .COMMENT - multi-line comment (simplified)
        if operator == '.COMMENT':
            return True

        # .REQUEST - request library search
        if operator == '.REQUEST':
            for op in ops:
                if self.pass_num == 2:
                    self.output.write_request_library(op.strip())
            return True

        # .PHASE/.DEPHASE - phase shift
        if operator in ('.PHASE', '.DEPHASE'):
            return True

        # END - end of source
        if operator == 'END':
            if ops:
                val, seg, ext, name = self.parse_expression(ops[0])
                if ext:
                    self.error("Cannot use external as entry point")
                else:
                    self.entry_point = (val, seg)
            return True

        # Conditional assembly
        if operator == 'IF' or operator == 'IFT':
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            else:
                val, _, _, _ = self.parse_expression(ops[0] if ops else '0')
                if val == 0:
                    self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator in ('IFE', 'IFF'):
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            else:
                val, _, _, _ = self.parse_expression(ops[0] if ops else '0')
                if val != 0:
                    self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator == 'IFDEF':
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            else:
                name = ops[0].strip() if ops else ''
                sym = self.symbols.get(name.upper())
                if not sym or (not sym.defined and not sym.external):
                    self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator == 'IFNDEF':
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            else:
                name = ops[0].strip() if ops else ''
                sym = self.symbols.get(name.upper())
                if sym and (sym.defined or sym.external):
                    self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator == 'IF1':
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            elif self.pass_num != 1:
                self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator == 'IF2':
            if self.cond_false_depth > 0:
                self.cond_false_depth += 1
            elif self.pass_num != 2:
                self.cond_false_depth = 1
            self.cond_stack.append(operator)
            return True

        if operator == 'ELSE':
            if not self.cond_stack:
                self.error("ELSE without IF")
                return True
            if self.cond_false_depth == 1:
                self.cond_false_depth = 0
            elif self.cond_false_depth == 0:
                self.cond_false_depth = 1
            return True

        if operator == 'ENDIF':
            if not self.cond_stack:
                self.error("ENDIF without IF")
                return True
            self.cond_stack.pop()
            if self.cond_false_depth > 0:
                self.cond_false_depth -= 1
            return True

        # INCLUDE
        if operator in ('INCLUDE', '$INCLUDE', 'MACLIB'):
            # Will be handled by caller
            return False

        # MACRO definition - starts collecting
        if operator == 'MACRO':
            if not label:
                self.error("MACRO requires a name (label)")
                return True
            # Parse parameters from operands
            params = []
            if operands:
                params = [p.strip().upper() for p in operands.split(',')]
            self.collecting_macro = label.upper()
            self.macro_params = params
            self.macro_body = []
            self.macro_nest_depth = 0
            return True

        # ENDM outside of macro definition is an error
        if operator == 'ENDM':
            self.error("ENDM without MACRO")
            return True

        # EXITM - exit from macro expansion
        if operator == 'EXITM':
            # Handled during expansion - here it just returns
            return True

        # LOCAL - declare local symbols in macro
        if operator == 'LOCAL':
            # Handled during expansion - here it's ignored
            return True

        # REPT - repeat block
        if operator == 'REPT':
            if not ops:
                self.error("REPT requires a count")
                return True
            count, _, _, _ = self.parse_expression(ops[0])
            self.repeat_stack.append(('REPT', count, [], None, label))
            return True

        # IRP - iterate with list
        if operator == 'IRP':
            if len(ops) < 2:
                self.error("IRP requires parameter and list")
                return True
            param = ops[0].strip().upper()
            # Rest of ops are the list values
            values = ops[1:]
            # Handle <> enclosed list
            if len(values) == 1 and values[0].startswith('<') and values[0].endswith('>'):
                values = [v.strip() for v in values[0][1:-1].split(',')]
            self.repeat_stack.append(('IRP', values, [], param, label))
            return True

        # IRPC - iterate over characters
        if operator == 'IRPC':
            if len(ops) < 2:
                self.error("IRPC requires parameter and string")
                return True
            param = ops[0].strip().upper()
            chars = ops[1].strip()
            if chars.startswith('<') and chars.endswith('>'):
                chars = chars[1:-1]
            self.repeat_stack.append(('IRPC', list(chars), [], param, label))
            return True

        # ENDM for REPT/IRP/IRPC
        # (Note: ENDM for MACRO is handled in process_line)

        return False  # Not a pseudo-op

    def process_line(self, line):
        """Process a single source line."""
        self.line_num += 1

        label, operator, operands, comment = self.parse_line(line)
        upper_op = operator.upper() if operator else ''

        # If collecting macro definition, handle specially
        if self.collecting_macro is not None:
            if upper_op == 'MACRO':
                # Nested macro definition
                self.macro_nest_depth += 1
                self.macro_body.append(line)
            elif upper_op == 'ENDM':
                if self.macro_nest_depth > 0:
                    self.macro_nest_depth -= 1
                    self.macro_body.append(line)
                else:
                    # End of macro definition
                    self.macros[self.collecting_macro] = Macro(
                        self.collecting_macro, self.macro_params, self.macro_body
                    )
                    self.collecting_macro = None
                    self.macro_params = []
                    self.macro_body = []
            else:
                self.macro_body.append(line)
            return

        # If collecting REPT/IRP/IRPC body, handle specially
        if self.repeat_stack:
            if upper_op in ('REPT', 'IRP', 'IRPC'):
                # Nested repeat - add to body and track nesting
                self.repeat_stack[-1][2].append(line)
                self.repeat_stack.append(('NESTED', 0, [], None, None))
            elif upper_op == 'ENDM':
                if len(self.repeat_stack) > 1 and self.repeat_stack[-1][0] == 'NESTED':
                    # End of nested repeat
                    self.repeat_stack.pop()
                    self.repeat_stack[-1][2].append(line)
                else:
                    # End of outer repeat - execute it
                    rept_type, param_or_count, body, iter_var, rept_label = self.repeat_stack.pop()
                    self.execute_repeat(rept_type, param_or_count, body, iter_var)
            else:
                self.repeat_stack[-1][2].append(line)
            return

        # Handle conditional directives even in false blocks
        if upper_op in ('IF', 'IFT', 'IFE', 'IFF', 'IFDEF', 'IFNDEF',
                        'IF1', 'IF2', 'ELSE', 'ENDIF'):
            self.assemble_pseudo_op(operator, operands, label)
            return

        if self.cond_false_depth > 0:
            return

        # Define label if present
        if label and upper_op not in ('EQU', 'SET', 'MACRO'):
            self.define_symbol(label, self.loc, self.seg_type)

        if not operator:
            return

        # Try CPU instruction
        if self.assemble_instruction(operator, operands):
            return

        # Try pseudo-op
        if self.assemble_pseudo_op(operator, operands, label):
            return

        # Check if it's a macro call
        if upper_op in self.macros:
            self.expand_macro(upper_op, operands)
            return

        self.error(f"Unknown instruction or directive: {operator}")

    def expand_macro(self, name, operands):
        """Expand a macro."""
        macro = self.macros.get(name)
        if not macro:
            self.error(f"Undefined macro: {name}")
            return

        # Parse actual arguments
        args = []
        if operands:
            args = self.split_operands(operands)

        # Build substitution map
        subst = {}
        for i, param in enumerate(macro.params):
            if i < len(args):
                subst[param] = args[i]
            else:
                subst[param] = ''  # Missing args become empty

        # Generate unique local symbol suffix
        self.local_counter += 1
        local_suffix = f'?{self.local_counter:04d}'

        # Track local symbols declared in this expansion
        local_syms = set()

        # Expand body lines with parameter substitution
        self.macro_level += 1
        for body_line in macro.body:
            # Check for LOCAL directive
            label, op, opnds, comment = self.parse_line(body_line)
            if op and op.upper() == 'LOCAL':
                # Add these symbols to local set
                if opnds:
                    for sym in opnds.split(','):
                        local_syms.add(sym.strip().upper())
                continue
            if op and op.upper() == 'EXITM':
                # Exit macro expansion early
                break

            # Substitute parameters and local symbols
            expanded = body_line
            for param, value in subst.items():
                # Replace &param with value (for concatenation)
                expanded = expanded.replace(f'&{param}', value)
                # Replace standalone param with value
                expanded = re.sub(r'\b' + re.escape(param) + r'\b', value, expanded, flags=re.IGNORECASE)

            # Replace local symbols with unique versions
            for local_sym in local_syms:
                expanded = re.sub(r'\b' + re.escape(local_sym) + r'\b',
                                  local_sym + local_suffix, expanded, flags=re.IGNORECASE)

            # Process the expanded line
            self.process_line(expanded)

        self.macro_level -= 1

    def execute_repeat(self, rept_type, param_or_count, body, iter_var):
        """Execute a REPT/IRP/IRPC block."""
        if rept_type == 'REPT':
            # Repeat body 'count' times
            count = param_or_count
            for i in range(count):
                for line in body:
                    self.process_line(line)

        elif rept_type == 'IRP':
            # Iterate with list of values
            values = param_or_count
            for value in values:
                for line in body:
                    # Substitute iter_var with value
                    expanded = line
                    if iter_var:
                        expanded = re.sub(r'\b' + re.escape(iter_var) + r'\b',
                                          value, expanded, flags=re.IGNORECASE)
                    self.process_line(expanded)

        elif rept_type == 'IRPC':
            # Iterate over characters
            chars = param_or_count
            for char in chars:
                for line in body:
                    # Substitute iter_var with character
                    expanded = line
                    if iter_var:
                        expanded = re.sub(r'\b' + re.escape(iter_var) + r'\b',
                                          char, expanded, flags=re.IGNORECASE)
                    self.process_line(expanded)

    def assemble_pass(self, lines, pass_num):
        """Run one pass of assembly."""
        self.pass_num = pass_num
        self.line_num = 0
        self.cond_stack = []
        self.cond_false_depth = 0

        # Reset segment locations for pass 2
        if pass_num == 2:
            for seg in self.segments.values():
                seg.loc = 0
            for com in self.common_blocks.values():
                com.loc = 0
            self.current_seg = 'CSEG'
            self.current_common = None

        for line in lines:
            self.process_line(line)

    def write_output(self):
        """Write the REL file content."""
        # Write module name
        name = self.module_name or 'MODULE'
        self.output.write_program_name(name)

        # Write entry symbols (for library search)
        for sym in self.symbols.values():
            if sym.public and sym.defined:
                self.output.write_entry_symbol(sym.name)

        # Reset for code generation
        for seg in self.segments.values():
            seg.loc = 0
        for com in self.common_blocks.values():
            com.loc = 0
        self.current_seg = 'CSEG'
        self.current_common = None

        # Second pass already wrote the code bytes

        # Write public symbol definitions
        for sym in self.symbols.values():
            if sym.public and sym.defined:
                self.output.write_define_entry_point(sym.seg_type, sym.value, sym.name)

        # Write external chains
        # The chain head is the LAST reference; linker walks backward through chain
        # Key is (name, expr_offset), so we emit separate entries for RNDX vs RNDX+1
        for (name, expr_offset), refs in self.ext_chains.items():
            if refs:
                # Get the last reference (head of chain)
                seg, offset = refs[-1]
                # For non-zero offsets, append "+N" to symbol name
                # Linker will parse this and add the offset to resolved address
                if expr_offset != 0:
                    sym_name = f"{name}+{expr_offset}"
                else:
                    sym_name = name
                self.output.write_chain_external(seg, offset, sym_name)

        # Write segment sizes
        cseg_size = self.segments['CSEG'].loc
        dseg_size = self.segments['DSEG'].loc

        if cseg_size > 0:
            self.output.write_define_program_size(cseg_size)
        if dseg_size > 0:
            self.output.write_define_data_size(dseg_size)

        # Write COMMON sizes
        for name, com in self.common_blocks.items():
            if com.loc > 0:
                self.output.write_define_common_size(ADDR_ABSOLUTE, com.loc, name if name else ' ')

        # Write end
        if self.entry_point:
            val, seg = self.entry_point
            self.output.write_end_program(val, seg)
        else:
            self.output.write_end_program()

        self.output.write_end_file()

    def assemble(self, source_file):
        """Assemble a source file."""
        # Read source - handle CP/M format (CR/LF, ^Z EOF, 128-byte records)
        with open(source_file, 'rb') as f:
            data = f.read()

        # Strip ^Z (0x1A) and everything after it (CP/M EOF marker)
        eof_pos = data.find(0x1A)
        if eof_pos >= 0:
            data = data[:eof_pos]

        # Decode to text, handling CR/LF and stripping trailing nulls
        text = data.decode('ascii', errors='replace')
        text = text.replace('\r\n', '\n').replace('\r', '\n')  # Normalize line endings
        text = text.rstrip('\x00')  # Strip padding nulls

        lines = text.split('\n')
        self.source_lines = lines

        # Pass 1: Build symbol table
        self.assemble_pass(lines, 1)

        if self.errors:
            return False

        # Pass 2: Generate code
        self.output = RELWriter()
        self.ext_chains = {}

        # Write module header
        name = self.module_name or Path(source_file).stem.upper()[:6]
        self.output.write_program_name(name)

        # Write entry symbols (PUBLIC symbols for library search)
        for sym in self.symbols.values():
            if sym.public and sym.defined:
                self.output.write_entry_symbol(sym.name)

        self.assemble_pass(lines, 2)

        if self.errors:
            return False

        # Finalize output
        # Write public symbol definitions
        for sym in self.symbols.values():
            if sym.public and sym.defined:
                self.output.write_define_entry_point(sym.seg_type, sym.value, sym.name)

        # Write external chains
        # The chain head is the LAST reference; linker walks backward through chain
        # Key is (name, expr_offset), so we emit separate entries for RNDX vs RNDX+1
        for (name, expr_offset), refs in self.ext_chains.items():
            if refs:
                # Get the last reference (head of chain)
                seg, offset = refs[-1]
                # For non-zero offsets, append "+N" to symbol name
                # Linker will parse this and add the offset to resolved address
                if expr_offset != 0:
                    sym_name = f"{name}+{expr_offset}"
                else:
                    sym_name = name
                self.output.write_chain_external(seg, offset, sym_name)

        # Write segment sizes
        cseg_size = self.segments['CSEG'].loc
        dseg_size = self.segments['DSEG'].loc

        if cseg_size > 0:
            self.output.write_define_program_size(cseg_size)
        if dseg_size > 0:
            self.output.write_define_data_size(dseg_size)

        # Write COMMON sizes
        for name, com in self.common_blocks.items():
            if com.loc > 0:
                self.output.write_define_common_size(ADDR_ABSOLUTE, com.loc, name if name else ' ')

        # Write end with optional entry point
        if self.entry_point:
            val, seg = self.entry_point
            self.output.write_end_program(val, seg)
        else:
            self.output.write_end_program()

        self.output.write_end_file()

        return True


def main():
    parser = argparse.ArgumentParser(description='um80 - MACRO-80 compatible assembler')
    parser.add_argument('input', help='Input .MAC file')
    parser.add_argument('-o', '--output', help='Output .REL file')
    parser.add_argument('-l', '--listing', help='Listing .PRN file')
    parser.add_argument('-D', '--define', action='append', metavar='SYMBOL[=VALUE]',
                        help='Define symbol (can be used multiple times)')

    args = parser.parse_args()

    # Determine output file name
    input_path = Path(args.input)
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = input_path.with_suffix('.rel')

    # Parse command line symbol definitions
    predefined = {}
    if args.define:
        for defn in args.define:
            if '=' in defn:
                name, val = defn.split('=', 1)
                try:
                    predefined[name.upper()] = int(val, 0)
                except ValueError:
                    predefined[name.upper()] = 1
            else:
                predefined[defn.upper()] = 1

    # Create assembler and run
    asm = Assembler(predefined=predefined)
    success = asm.assemble(args.input)

    # Report errors and warnings
    for err in asm.errors:
        print(err.format_message(), file=sys.stderr)
    for warn in asm.warnings:
        print(warn, file=sys.stderr)

    if not success:
        sys.exit(1)

    # Write output
    with open(output_path, 'wb') as f:
        f.write(asm.output.get_bytes())

    print(f"Assembled {args.input} -> {output_path}")
    print(f"  Code segment: {asm.segments['CSEG'].loc} bytes")
    print(f"  Data segment: {asm.segments['DSEG'].loc} bytes")
    print(f"  Symbols: {len(asm.symbols)}")

    sys.exit(0)


if __name__ == '__main__':
    main()
