.TH UD80 1 "November 2025" "um80 1.0.0" "User Commands"
.SH NAME
ud80 \- 8080/Z80 disassembler for CP/M .COM files
.SH SYNOPSIS
.B ud80
[\fB\-z\fR]
[\fB\-o\fR \fIoutput.mac\fR]
[\fB\-e\fR \fIaddress\fR]...
[\fB\-d\fR \fIstart\-end\fR]...
[\fB\-\-org\fR \fIaddress\fR]
.I input.com
.SH DESCRIPTION
.B ud80
is a disassembler for 8080 and Z80 binary files, designed to produce output
compatible with the
.BR um80 (1)
assembler. It converts CP/M .COM executable files (or raw binary files) back
into assembly source code that can be modified and reassembled.
.PP
The disassembler performs flow analysis starting from entry points to distinguish
code from data. Unvisited bytes are output as DB directives. The output is
designed to reassemble to an identical binary with um80.
.SH OPTIONS
.TP
.BR \-z ", " \-\-z80
Enable Z80 mode. In this mode:
.RS
.IP \(bu 2
Z80 extended instructions are decoded (CB, DD, ED, FD prefixes)
.IP \(bu 2
Undocumented Z80 instructions are recognized
.IP \(bu 2
Zilog mnemonics are used in the output
.RE
.IP
Without this flag, only 8080 instructions are decoded using Intel mnemonics.
.TP
.BI \-o " output.mac"
Specify the output file name. Default is the input file name with a .mac extension.
.TP
.BI \-e " address"
Add an entry point at the specified hexadecimal address. Flow analysis will
trace execution from this address. Can be specified multiple times.
.IP
By default, the disassembler starts at the origin address (typically 0100h for
CP/M programs). Use \-e to add additional entry points for code that isn't
reached by normal flow (interrupt handlers, jump tables, etc.).
.TP
.BI \-d " start\-end"
Force a range of addresses to be treated as data, not code. Both \fIstart\fR
and \fIend\fR are hexadecimal addresses. The range is inclusive.
Can be specified multiple times.
.IP
Use this for embedded data tables that might otherwise be incorrectly
disassembled as instructions.
.TP
.BI \-\-org " address"
Set the origin address (where the binary is loaded in memory). Default is 0100h,
the standard CP/M transient program area. The address is in hexadecimal.
.SH FLOW ANALYSIS
.B ud80
performs recursive descent disassembly starting from entry points:
.IP 1. 3
Begin at each entry point
.IP 2.
Decode instructions, following sequential execution
.IP 3.
When encountering branches (JMP, JNZ, CALL, etc.), queue branch targets
.IP 4.
Stop tracing at unconditional jumps, returns, and halts
.IP 5.
Continue until all reachable code is traced
.PP
This approach correctly identifies code vs. data in most cases, but may miss
code only reached through computed jumps or interrupt vectors.
.SH OUTPUT FORMAT
The output is a valid
.BR um80 (1)
source file:
.PP
.RS
.nf
; Disassembly of program.com
; Generated by ud80

        ORG     0100H

L0100:  JMP     L0150       ; Jump to main
L0103:  DB      0,0,0       ; Data bytes
        ...
L0150:  MVI     A,0         ; Main entry
        ...
        END     L0100
.fi
.RE
.PP
Features of the output:
.IP \(bu 2
Labels are generated for all branch targets (L\fIxxxx\fR format)
.IP \(bu 2
Unreachable bytes are output as DB directives
.IP \(bu 2
String-like data is shown as DB with ASCII strings where possible
.IP \(bu 2
The END directive includes the entry point
.SH 8080 vs Z80 MODE
.SS 8080 Mode (default)
Uses Intel 8080 mnemonics:
.IP \(bu 2
MOV, MVI, LXI for data movement
.IP \(bu 2
ADD, ADC, SUB, SBB for arithmetic
.IP \(bu 2
ANA, XRA, ORA for logic
.IP \(bu 2
JMP, JNZ, JZ, CALL, RET for control flow
.IP \(bu 2
Registers: A, B, C, D, E, H, L, M, SP, PSW
.SS Z80 Mode (\-z)
Uses Zilog Z80 mnemonics:
.IP \(bu 2
LD for most data movement
.IP \(bu 2
ADD, ADC, SUB, SBC for arithmetic
.IP \(bu 2
AND, XOR, OR for logic
.IP \(bu 2
JP, JR, CALL, RET, DJNZ for control flow
.IP \(bu 2
Additional registers: IX, IY, I, R
.IP \(bu 2
Extended instructions: LDIR, CPIR, bit operations, etc.
.PP
Z80 mode also decodes the CB, DD, ED, and FD prefix instructions, including
undocumented opcodes for the IXH, IXL, IYH, IYL registers.
.SH EXAMPLES
.TP
Basic disassembly:
.B ud80 program.com
.TP
Z80 mode:
.B ud80 \-z program.com
.TP
Custom output file:
.B ud80 \-o source.mac program.com
.TP
Add entry point:
.B ud80 \-e 0200 program.com
.TP
Multiple entry points:
.B ud80 \-e 0200 \-e 0300 \-e 0400 program.com
.TP
Force data range:
.B ud80 \-d 0500\-05FF program.com
.TP
Non-CP/M binary at 0000h:
.B ud80 \-\-org 0000 bios.bin
.TP
Combine options:
.B ud80 \-z \-e 0200 \-d 0300\-03FF \-o source.mac game.com
.SH ROUND-TRIP VERIFICATION
To verify disassembly quality, reassemble and compare:
.PP
.RS
.nf
ud80 program.com
um80 program.mac
ul80 program.rel
cmp program.com program.new
.fi
.RE
.PP
If the files match, the disassembly is accurate.
.SH TIPS
.SS Finding Entry Points
.IP \(bu 2
Look for interrupt vectors at fixed addresses (RST handlers, etc.)
.IP \(bu 2
Search for jump table patterns
.IP \(bu 2
Examine call targets that flow analysis missed
.SS Identifying Data
.IP \(bu 2
Strings of ASCII characters
.IP \(bu 2
Tables of addresses (pairs of bytes)
.IP \(bu 2
Sequences that don't decode as valid instructions
.IP \(bu 2
Areas following unconditional jumps that aren't targeted by branches
.SS Iterative Refinement
.IP 1. 3
Run initial disassembly
.IP 2.
Examine output for incorrectly decoded data
.IP 3.
Add \-d flags for data regions
.IP 4.
Add \-e flags for missed code
.IP 5.
Re-disassemble and verify
.SH EXIT STATUS
.TP
.B 0
Disassembly successful.
.TP
.B 1
Error occurred (file not found, invalid address, etc.).
.SH FILES
.TP
.I input.com
Input binary file (CP/M executable or raw binary).
.TP
.I output.mac
Output assembly source file.
.SH LIMITATIONS
.IP \(bu 2
Self-modifying code cannot be correctly disassembled.
.IP \(bu 2
Computed jumps (JP (HL), etc.) don't contribute to flow analysis.
.IP \(bu 2
Overlay areas or banked memory cannot be handled automatically.
.IP \(bu 2
CP/M system calls are not annotated (would require additional analysis).
.SH SEE ALSO
.BR um80 (1),
.BR ul80 (1),
.BR ulib80 (1),
.BR ucref80 (1)
.SH HISTORY
.B ud80
was created as a companion tool for the um80 assembler toolchain. Unlike the
other tools which are implementations of Microsoft originals, ud80 is a new
tool designed to complement the toolchain by enabling disassembly of existing
CP/M programs.
.SH AUTHOR
um80 project contributors.
